# Log Data Model

Introduce Data Model for Log Records as it is understood by OpenTelemetry.

* [Motivation](#motivation)
* [Design Notes](#design-notes)
  * [Requirements](#requirements)
  * [Field Kinds](#field-kinds)
* [Logical Data Model vs Physical Format](#logical-data-model-vs-physical-format)
* [Log and Event Record Definition](#log-and-event-record-definition)
  * [Field: `timestamp`](#field-timestamp)
  * [Trace Context:](#trace-context)
    * [Field: `trace_id`](#field-traceid)
    * [Field: `span_id`](#field-spanid)
    * [Field: `trace_flags`](#field-traceflags)
  * [Severity](#severity)
    * [Field: `severity_text`](#field-severitytext)
    * [Field: `severity_number`](#field-severitynumber)
    * [Displaying Severity](#displaying-severity)
    * [Comparing Severity](#comparing-severity)
  * [Field: `short_name`](#field-shortname)
  * [Field: `body`](#field-body)
  * [Field: `resource`](#field-resource)
  * [Field: `attributes`](#field-attributes)
* [Representation](#representation)
* [Prior Art](#prior-art)
  * [RFC5424 Syslog](#rfc5424-syslog)
  * [Fluentd Forward Protocol Model](#fluentd-forward-protocol-model)
* [Appendix A. Example Mappings.](#appendix-a-example-mappings)
  * [RFC5424 Syslog](#rfc5424-syslog-1)
  * [Windows Event Log](#windows-event-log)
  * [SignalFx Events](#signalfx-events)
  * [Splunk HEC](#splunk-hec)
  * [Log4j](#log4j)
  * [Zap](#zap)
  * [Apache](#apache)
  * [CloudTrail Log Event](#cloudtrail-log-event)
* [Appendix B: `severity_number` example mappings.](#appendix-b-severitynumber-example-mappings)
* [Reference](#reference)

## Motivation

This is a proposal of a data model and semantic conventions that allow to
represent logs from various sources: application log files, machine generated
events, system logs, etc. Existing log formats can be unambiguously mapped to
this data model. Reverse mapping from this data model is also possible to the
extent that the target log format has equivalent capabilities.

The purpose of the data model is to have a common understanding of what a log
record is, what data needs to be recorded, transferred, stored and interpreted
by a logging system.

## Design Notes

### Requirements

This Data Model was designed to satisfy the following requirements:

- It should be possible to unambiguously map existing log formats to this Data
  Model. Translating log data from an arbitrary log format to this Data Model
  and back should ideally result in identical data.

- Mappings of other log formats to this Data Model should be semantically
  meaningful. The Data Model must preserve the semantics of particular elements
  of existing log formats.

- Translating log data from an arbitrary log format A to this Data Model and
  then translating from the Data Model to another log format B ideally must
  result in a meaningful, lossless translation of log data that is no worse than
  a reasonable direct translation from log format A to log format B.

- It should be possible to efficiently represent the Data Model in concrete
  implementations that require the data to be stored or transmitted. We
  primarily care about 2 aspects of efficiency: CPU usage for
  serialization/deserialization and space requirements in serialized form. This
  is an indirect requirement that is affected by the specific representation of
  the Data Model rather than the Data Model itself, but is still useful to keep
  in mind.

The data model aims to successfully represent 3 sorts of logs and events:

- System Formats. These are logs and events generated by the operating system
  and over which we have no control - we cannot change the format or affect what
  information is included (unless the data is generated by an application which
  we can modify). An example of system format is Syslog.

- Third-party Applications. These are generated by third-party applications. We
  may have certain control over what information is included, e.g. customize the
  format. An example is Apache log file.

- First-party Applications. These are applications that we develop and we have
  some control over how the logs and events are generated and what information
  we include in the logs. We can likely modify the source code of the
  application if needed.

### Field Kinds

This data model defines a logical model for a log record (irrespective of the
physical format and encoding of the record). Each record contains 2 kinds of
fields:

- Named top-level fields of specific type and meaning.

- Fields stored in the key/value pair lists, which can contain arbitrary values
  of different types. The keys and values for well-known fields follow semantic
  conventions for key names and possible values that allow all parties that work
  with the field to have the same interpretation of the data (see references to
  semantic conventions for Resource and Attributes fields and examples in
  Appendix A).

The reasons for having these 2 kinds of fields is:

- Ability to efficiently represent named top-level fields, which are almost
  always present (e.g. when using encodings like Protocol Buffers where fields
  are enumerated but not named on the wire), and to enforce their types and
  domain of values, which is very useful for compiled languages with type
  checks.

- Flexibility to represent less frequent data via key/value pair lists. This
  includes well-known data that has standardized semantics as well as arbitrary
  custom data that the application may want to include in the logs.

When designing this data model I followed the following reasoning to make a
decision about when to use use a top-level named field:

- The field needs to be either mandatory for all records or be frequently
  present in well-known log and event formats (such as timestamp) or is expected
  to be often present in log records in upcoming logging systems (such as
  trace_id).

- The field’s semantics must be the same for all known log and event formats and
  can be mapped directly and unambiguously to this data model.
  
Both of the above conditions were required to give the field a place in the
top-level structure of the record.

## Logical Data Model vs Physical Format

The data model does not define the actual encoding and format of the log record
representation. Format definitions will be done in separate OTEPs (e.g the log
records may be represented as msgpack, JSON, Protocol Buffer messages, etc).

## Log and Event Record Definition

Note: below we use type any, which can be a scalar value (number, string or
boolean), or an array or map of values. Arbitrary deep nesting of values for
arrays and maps is allowed (essentially allow to represent an equivalent of a
JSON object).

Appendix A contains many examples that show how existing log formats map to the
fields defined below. If there are questions about the meaning of the field
reviewing the examples may be helpful.

Here is the list of fields in a log record:

Field Name     |
---------------|
timestamp      |
trace_id       |
span_id        |
trace_flags    |
severity_text  |
severity_number|
short_name     |
body           |
resource       |
attributes     |

Below is the detailed description of each field.


### Field: `timestamp`

Type: Timestamp, uint64 nanosecods since Unix epoch

Description: Time when the event occurred measured by the origin clock. This
field is optional, it may be missing the timestamp is unknown.

### Trace Context:

#### Field: `trace_id`

Type: byte sequence

Description: Optional request trace id. Can be set for logs that are part of
request processing and have an assigned trace id.

#### Field: `span_id`

Type: byte sequence

Description: Optional span id. Can be set for logs that are part of a particular
processing span. If span_id is present trace_id SHOULD be also present.

#### Field: `trace_flags`

Type: byte

Description: Optional trace flag as defined in W3C trace context specification.
At the time of writing the specification defines one flag - the SAMPLED flag.

### Severity

#### Field: `severity_text`

Type: string

Description: the severity text (also known as log level). This is an optional
field and is the original string representation as it is known at the source. If
this field is missing and `severity_number` is present then the short name that
corresponds to the `severity_number` can be used as a substitution.

#### Field: `severity_number`

Type: number

Description: numerical value of the severity, normalized to values described in
this document. This is an optional field. If `severity_number` is missing and
severity_text is present then it may be assumed that `severity_number` is equal
to INFO (numeric 9) (see the meaning below).

`severity_number` is an integer number. Smaller numerical values correspond to
less severe events (such as debug events), larger numerical values correspond to
more severe events (such as errors and critical events). The following table
defines the meaning of `severity_number` value:

severity_number range|Range name|Meaning
---------------------|----------|-------
1-4                  |TRACE     |A fine-grained debugging event. Typically disabled in default configurations.
5-8                  |DEBUG     |A debugging event. Often is not emitted in default configurations.
9-12                 |INFO      |An informational event. Indicates that an event happened.
13-16                |WARN      |A warning event. Not an error but is likely more important than an informational event.
17-20                |ERROR     |An error event. Something went wrong.
21-24                |FATAL     |A fatal error such as application or system crash.

Smaller numerical values in each range represent less important (less severe)
events. Larger numerical values in each range represent more important (more
severe) events. For example `severity_number=17` describes an error that is less
critical than an error with `severity_number=20`.

*Mapping of `severity_number`*

Mappings from existing logging systems and formats (of source format for short)
must define how severity (or log level) of that particular format corresponds to
`severity_number` of this data model based on the meaning listed for each range in
the above table.

If the source format has more than one severity that matches a single range in
this table then the severities of the source format must be assigned numerical
values from that range according to how severe (important) the source severity
is.

For example if the source format defines "Error" and "Critical" as error events
and "Critical" is a more important and more severe situation then we can choose
the following `severity_number` values for the mapping: "Error"->17,
"Critical"->18.

If the source format has only a single severity that matches the meaning of the
range then it is recommended to assign that severity the initial value of the
range. 

For example if the source format has an "Informational" log level and no other
log levels with similar meaning then it is recommended to use `severity_number=9`
for "Informational".

Source formats that do not define a concept of severity or log level MAY omit
`severity_number` and severity_text fields. Backend and UIs may represent log
records with missing severity information distinctly or may interpret log
records with missing `severity_number` and `severity_text` fields as if the
`severity_number` was set equal to INFO (numeric value of 9).

*Reverse Mapping*

When performing a reverse mapping from `severity_number` to a specific format and
the `severity_number` has no corresponding mapping entry for that format then it
is recommended to choose the target severity that is in the same severity range
and is closest numerically.

For example Zap has only one severity in the INFO range, called "Info". When
doing reverse mapping all values in INFO range (numeric 9-12) will be mapped to
Log4J’s "Info" level.

*Error Semantics*

If `severity_number` is present and has a value of ERROR (numeric 17) or higher
then it is an indication that the log record represents an erroneous situation.
It is up to the reader of this value to make a decision on how to use this fact
(e.g. UIs may display such errors in a different color or have a feature to find
all "errors").

If the log record represents an erroneous event and the source format does not
define a severity or log record field it is recommended to set severity_number
to ERROR (numeric 17) during the mapping process. If the log record represents a
non-erroneous event the `severity_number` field may be omitted or may be set to
any numeric value less than ERROR (numeric 17). The recommended value in this
case is INFO (numeric 9). See Appendix for more mapping examples.

#### Displaying Severity 

The following table defines the recommended short name for each
`severity_number` value (this can be used for example for representing the
`severity_number` in the UI):

severity_number|Short Name
---------------|----------
1              |TRACE
2              |TRACE2
3              |TRACE3
4              |TRACE4
5              |DEBUG
6              |DEBUG2
7              |DEBUG3
8              |DEBUG4
9              |INFO
10             |INFO2
11             |INFO3
12             |INFO4
13             |WARN
14             |WARN2
15             |WARN3
16             |WARN4
17             |ERROR
18             |ERROR2
19             |ERROR3
20             |ERROR4
21             |FATAL
22             |FATAL2
23             |FATAL3
24             |FATAL4

When an individual log record is displayed it is recommended to show both
severity_text and seveirty_number values. A recommended combined string in this
case begins with the short name followed by severity_text in parenthesis.

For example "Informational" Syslog record will be displayed as INFO
(Informational). When for a particular log record the `severity_number` is
defined but the severity_text is missing it is recommended to only show the
short name, e.g. INFO.

When drop down lists or other UI elements that are intended to represent the
possible set of values are used for representing the severity it is likely
preferable to use the short names.

For example a dropdown list of severities that allows filtering log records by
severities is likely to be more usable if it contains the short names of
`severity_number` (and thus has a limited upper bound of elements) compared to a
dropdown list which lists all distinct severity_text values that are known to
the system (which can be a large number of elements, often differing only in
capitalization or abbreviated, e.g. "Info" vs "Information").

#### Comparing Severity

In the contexts where severity participates less-than / greater-than comparisons
`severity_number` field should be used. `severity_number` can be compared to
another `severity_number` or to numbers in the 1..24 range (or to the
corresponding short names).

When severity is used in equality or inequality comparisons (for example in
filters in the UIs) the recommendation is to attempt to use both severity_text
and short name of `severity_number` to perform matches. For example if we have a
record with severity_text field equal to "Informational" and `severity_number`
field equal to INFO then it may be preferable from the user experience
perspective to ensure that severity="Informational" and severity="INFO"
conditions both to are TRUE for that record.

### Field: `short_name`

Type: string

Description: Short event identifier that does not contain varying parts.
`short_name` describes what happened (e.g. "ProcessStarted"). Recommended to be
no longer than 50 characters. Optional. Not guaranteed to be unique in any way.
Typically used for filtering and grouping purposes in backends.

### Field: `body`

Type: any

Description: A value containing the body of the log record (see the description
of any type above). Can be for example a human-readable string message
(including multi-line) describing the event in a free form or it can be a
structured data composed of arrays and maps of other values. Can vary for each
occurrence of the event coming from the same source.

### Field: `resource`

Type: key/value pair list

Description: Describes the source of the log, aka
[resource](https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md#resources).
"value" is of any type. Multiple occurrences of events coming from the same
event source can happen across time and they all have the same value of
resource. Can contain for example information about the application that emits
the record or about the infrastructure where the application runs. Data formats
that represent this data model may be designed in a manner that allows the
`resource` field to be recorded only once per batch of log records that come
from the same source. SHOULD follow OpenTelemetry
[semantic conventions](https://github.com/open-telemetry/opentelemetry-specification/tree/master/specification/resource/semantic_conventions)
for Resources.

### Field: `attributes`

Type: key/value pair list

Description: Additional information about the specific event occurrence. "value"
is of any type. Unlike the resource field, which is fixed for a particular
source, attributes can vary for each occurrence of the event coming from the same
source. Can contain information about the request context (other than
TraceId/SpanId). SHOULD follow OpenTelemetry
[semantic conventions](https://github.com/open-telemetry/opentelemetry-specification/tree/master/specification/trace/semantic_conventions)
for Attributes.

## Representation

Representation of Log Data over the wire and the transmission protocol is to be
defined. 

Below are examples that show one possible representation in JSON. Note: this is
just an example to help understand the data model, don’t treat it as the way to
represent this data model in JSON, that is still to be defined.

Example 1

```json
{
  "timestamp": 1586960586000, // JSON needs to make a decision about 
                              // how to represent nanos.
  "attributes": {
    "http.status_code": 500,
    "http.url": "http://example.com",
    "my.custom.application.tag": "hello",
  },
  "resource": {
    "service.name": "donut_shop",
    "service.version": "semver:2.0.0",
    "k8s.pod.name": "1138528c-c36e-11e9-a1a7-42010a800198",
  },
  "trace_id": "f4dbb3edd765f620", // this is a byte sequence 
                                  // (hex-encoded in JSON)
  "span_id": "43222c2d51a7abe3",
  "severity": "INFO",
  "body": "20200415T072306-0700 INFO I like donuts"
}
```

Example 2

```json
{
  "timestamp": 1586960586000,
  ...
  "body": {
    "i": "am",
    "an": "event",
    "of": {
      "some": "complexity"
    }
  }
}
```

## Prior Art

### RFC5424 Syslog

RFC5424 defines structure log data format and protocol. The protocol is
ubiquitous (although unfortunately many implementations don’t follow structured
data recommendations). Here are some drawbacks that do not make Syslog a serious
contender for a data model:

- While it allows structured attributes the body of the message can be only a
  string.

- Severity is hard-coded to 8 possible numeric values, and does not allow custom
  severity labels.

- Structured data does not allow arbitrary nesting and is 2-level only.

- No clear separate place to specify data source (aka resource). There are a
  couple hard-coded fields that serve this purpose in a limited way (HOSTNAME,
  APP-NAME, FACILITY).

### Fluentd Forward Protocol Model

Forward protocol defines a log Entry concept as a timestamped record. The record
consists of 2 elements: a tag and a map of arbitrary key/value pairs.

The model is universal enough to represent any log record. However, here are
some drawbacks:

- All attributes of a record are represented via generic key/value pairs (except
  tag and timestamp). This misses the optimization opportunities (see [Design
  Notes](#design-notes)).

- There is no clear separate place to specify data source (aka resource).

- There is no mention of how exactly keys should be named and what are expected
  values. This lack of any naming convention or standardization of key/value
  pairs makes interoperability difficult.


## Appendix A. Example Mappings.

This section contains examples of mapping of legacy events and logs formats to
the new universal data model.

### RFC5424 Syslog

<table>
  <tr>
    <td>Property</td>
    <td>Type</td>
    <td>Description</td>
    <td>Maps to Unified Model Field</td>
  </tr>
  <tr>
    <td>TIMESTAMP</td>
    <td>timestamp</td>
    <td>Time when an event occurred measured by the origin clock.</td>
    <td>timestamp</td>
  </tr>
  <tr>
    <td>SEVERITY</td>
    <td>enum</td>
    <td>Defines the importance of the event. Example: `Debug`</td>
    <td>severity</td>
  </tr>
  <tr>
    <td>FACILITY</td>
    <td>enum</td>
    <td>Describes where the event originated. A predefined list of Unix processes. Part of event source identity. Example: `mail system`</td>
    <td>attributes["syslog.facility"]</td>
  </tr>
  <tr>
    <td>VERSION</td>
    <td>number</td>
    <td>Meta: protocol version, orthogonal to the event.</td>
    <td>attributes["syslog.version"]</td>
  </tr>
  <tr>
    <td>HOSTNAME</td>
    <td>string</td>
    <td>Describes the location where the event originated. Possible values are FQDN, IP address, etc.</td>
    <td>resource["host.hostname"]</td>
  </tr>
  <tr>
    <td>APP-NAME</td>
    <td>string</td>
    <td>User-defined app name. Part of event source identity.</td>
    <td>resource["service.name"]</td>
  </tr>
  <tr>
    <td>PROCID</td>
    <td>string</td>
    <td>Not well defined. May be used as a meta field for protocol operation purposes or may be part of event source identity.</td>
    <td>attributes["syslog.procid"]</td>
  </tr>
  <tr>
    <td>MSGID</td>
    <td>string</td>
    <td>Defines the type of the event. Part of event source identity. Example: "TCPIN"</td>
    <td>short_description</td>
  </tr>
  <tr>
    <td>STRUCTURED-DATA</td>
    <td>array of maps of string to string</td>
    <td>A variety of use cases depending on the SDID:
Can describe event source identity
Can include data that describes particular occurence of the event.
Can be meta-information, e.g. quality of timestamp value.</td>
    <td>SDID origin.swVersion map to resource["service.version"]

SDID origin.ip map to attribute[net.host.ip"]

Rest of SDIDs -> attributes["syslog.*"]</td>
  </tr>
  <tr>
    <td>MSG</td>
    <td>string</td>
    <td>Free-form text message about the event. Typically human readable.</td>
    <td>body</td>
  </tr>
</table>


### Windows Event Log

<table>
  <tr>
    <td>Property</td>
    <td>Type</td>
    <td>Description</td>
    <td>Maps to Unified Model Field</td>
  </tr>
  <tr>
    <td>TimeCreated</td>
    <td>timestamp</td>
    <td>The time stamp that identifies when the event was logged.</td>
    <td>timestamp</td>
  </tr>
  <tr>
    <td>Level</td>
    <td>enum</td>
    <td>Contains the severity level of the event.</td>
    <td>severity</td>
  </tr>
  <tr>
    <td>Computer</td>
    <td>string</td>
    <td>The name of the computer on which the event occurred.</td>
    <td>resource["host.hostname"]</td>
  </tr>
  <tr>
    <td>EventID</td>
    <td>uint</td>
    <td>The identifier that the provider used to identify the event.</td>
    <td>short_description</td>
  </tr>
  <tr>
    <td>Message</td>
    <td>string</td>
    <td>The message string.</td>
    <td>body</td>
  </tr>
  <tr>
    <td>Rest of the fields.</td>
    <td>any</td>
    <td>All other fields in the event.</td>
    <td>attributes["winlog.*"]</td>
  </tr>
</table>


### SignalFx Events

<table>
  <tr>
    <td>Field</td>
    <td>Type</td>
    <td>Description</td>
    <td>Maps to Unified Model Field</td>
  </tr>
  <tr>
    <td>Timestamp</td>
    <td>timestamp</td>
    <td>Time when the event occurred measured by the origin clock.</td>
    <td>timestamp</td>
  </tr>
  <tr>
    <td>EventType</td>
    <td>string</td>
    <td>Short machine understandable string describing the event type. SignalFx specific concept. Non-namespaced. Example: k8s Event Reason field.</td>
    <td>short_description</td>
  </tr>
  <tr>
    <td>Category</td>
    <td>enum</td>
    <td>Describes where the event originated and why. SignalFx specific concept. Example: AGENT. </td>
    <td>attributes["com.splunk.signalfx.event_category"]</td>
  </tr>
  <tr>
    <td>Dimensions</td>
    <td>map of string to string</td>
    <td>Helps to define the identity of the event source together with EventType and Category. Multiple occurrences of events coming from the same event source can happen across time and they all have the value of Dimensions. </td>
    <td>resource</td>
  </tr>
  <tr>
    <td>Properties</td>
    <td>map of string to any</td>
    <td>Additional information about the specific event occurrence. Unlike Dimensions which are fixed for a particular event source, Properties can have different values for each occurence of the event coming from the same event source.</td>
    <td>attributes</td>
  </tr>
</table>


### Splunk HEC

<table>
  <tr>
    <td>Field</td>
    <td>Type</td>
    <td>Description</td>
    <td>Maps to Unified Model Field</td>
  </tr>
  <tr>
    <td>time</td>
    <td>numeric, string</td>
    <td>The event time in epoch time format, in seconds.</td>
    <td>timestamp</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>host</td>
    <td>string</td>
    <td>The host value to assign to the event data. This is typically the host name of the client that you are sending data from.</td>
    <td>resource["host.hostname"]</td>
  </tr>
  <tr>
    <td>source</td>
    <td>string</td>
    <td>The source value to assign to the event data. For example, if you are sending data from an app you are developing, you could set this key to the name of the app.</td>
    <td>resource["service.name"]</td>
  </tr>
  <tr>
    <td>sourcetype</td>
    <td>string</td>
    <td>The sourcetype value to assign to the event data.</td>
    <td>attributes["source.type"]</td>
  </tr>
  <tr>
    <td>event</td>
    <td>any</td>
    <td>The JSON representation of the raw body of the event. It can be a string, number, string array, number array, JSON object, or a JSON array.</td>
    <td>body</td>
  </tr>
  <tr>
    <td>fields</td>
    <td>Map of any</td>
    <td>Specifies a JSON object that contains explicit custom fields.</td>
    <td>attributes</td>
  </tr>
  <tr>
    <td>index</td>
    <td>string</td>
    <td>The name of the index by which the event data is to be indexed. The index you specify here must be within the list of allowed indexes if the token has the indexes parameter set.</td>
    <td>TBD, most like will go to attributes</td>
  </tr>
</table>


### Log4j

<table>
  <tr>
    <td>Field</td>
    <td>Type</td>
    <td>Description</td>
    <td>Maps to Unified Model Field</td>
  </tr>
  <tr>
    <td>Instant</td>
    <td>timestamp</td>
    <td>Time when an event occurred measured by the origin clock.</td>
    <td>timestamp</td>
  </tr>
  <tr>
    <td>Level</td>
    <td>enum</td>
    <td>Log level.</td>
    <td>severity</td>
  </tr>
  <tr>
    <td>Message</td>
    <td>string</td>
    <td>Human readable message.</td>
    <td>body</td>
  </tr>
  <tr>
    <td>All other fields</td>
    <td>any</td>
    <td>Structured data.</td>
    <td>attributes</td>
  </tr>
</table>


### Zap

<table>
  <tr>
    <td>Field</td>
    <td>Type</td>
    <td>Description</td>
    <td>Maps to Unified Model Field</td>
  </tr>
  <tr>
    <td>ts</td>
    <td>timestamp</td>
    <td>Time when an event occurred measured by the origin clock.</td>
    <td>timestamp</td>
  </tr>
  <tr>
    <td>level</td>
    <td>enum</td>
    <td>Logging level.</td>
    <td>severity</td>
  </tr>
  <tr>
    <td>caller</td>
    <td>string</td>
    <td>Calling function's filename and line number.
</td>
    <td>attributes, key=TBD</td>
  </tr>
  <tr>
    <td>msg</td>
    <td>string</td>
    <td>Human readable message.</td>
    <td>body</td>
  </tr>
  <tr>
    <td>All other fields</td>
    <td>any</td>
    <td>Structured data.</td>
    <td>attributes</td>
  </tr>
</table>


### Apache

<table>
  <tr>
    <td>Field</td>
    <td>Type</td>
    <td>Description</td>
    <td>Maps to Unified Model Field</td>
  </tr>
  <tr>
    <td>%t</td>
    <td>timestamp</td>
    <td>Time when an event occurred measured by the origin clock.</td>
    <td>timestamp</td>
  </tr>
  <tr>
    <td>%a</td>
    <td>string</td>
    <td>Client IP</td>
    <td>attributes["net.peer.ip"]</td>
  </tr>
  <tr>
    <td>%A</td>
    <td>string</td>
    <td>Server IP</td>
    <td>attributes["net.host.ip"]</td>
  </tr>
  <tr>
    <td>%h</td>
    <td>string</td>
    <td>Remote hostname. </td>
    <td>attributes["net.peer.name"]</td>
  </tr>
  <tr>
    <td>%m</td>
    <td>string</td>
    <td>The request method.</td>
    <td>attributes["http.method"]</td>
  </tr>
  <tr>
    <td>%v,%p,%U,%q</td>
    <td>string</td>
    <td>Multiple fields that can be composed into URL.</td>
    <td>attributes["http.url"]</td>
  </tr>
  <tr>
    <td>%>s</td>
    <td>string</td>
    <td>Response status.</td>
    <td>attributes["http.status_code"]</td>
  </tr>
  <tr>
    <td>All other fields</td>
    <td>any</td>
    <td>Structured data.</td>
    <td>attributes, key=TBD</td>
  </tr>
</table>


### CloudTrail Log Event

<table>
  <tr>
    <td>Field</td>
    <td>Type</td>
    <td>Description</td>
    <td>Maps to Unified Model Field</td>
  </tr>
  <tr>
    <td>eventTime</td>
    <td>string</td>
    <td>The date and time the request was made, in coordinated universal time (UTC).</td>
    <td>timestamp</td>
  </tr>
  <tr>
    <td>eventSource</td>
    <td>string</td>
    <td>The service that the request was made to. This name is typically a short form of the service name without spaces plus .amazonaws.com.</td>
    <td>resource["service.name"]?</td>
  </tr>
  <tr>
    <td>awsRegion</td>
    <td>string</td>
    <td>The AWS region that the request was made to, such as us-east-2.</td>
    <td>resource["cloud.region"]</td>
  </tr>
  <tr>
    <td>sourceIPAddress</td>
    <td>string</td>
    <td>The IP address that the request was made from.</td>
    <td>resource["net.peer.ip"] or resource["net.host.ip"]? TBD</td>
  </tr>
  <tr>
    <td>errorCode</td>
    <td>string</td>
    <td>The AWS service error if the request returns an error.</td>
    <td>short_description</td>
  </tr>
  <tr>
    <td>errorMessage</td>
    <td>string</td>
    <td>If the request returns an error, the description of the error.</td>
    <td>body</td>
  </tr>
  <tr>
    <td>All other fields</td>
    <td>*</td>
    <td></td>
    <td>attributes["cloudtrail.*"]</td>
  </tr>
</table>


## Appendix B: `severity_number` example mappings.

Syslog       |WinEvtLog  |Log4j |Zap   |severity_number
-------------|-----------|------|------|---------------
-            |-          |TRACE |-     |TRACE 
Debug        |Verbose    |DEBUG |Debug |DEBUG
Informational|Information|INFO  |Info  |INFO
Notice       |           |      |      |INFO2
Warning      |Warning    |WARN  |Warn  |WARN
Error        |Error      |ERROR |Error |ERROR
Critical     |Critical   |-     |Dpanic|ERROR2
-            |-          |-     |Panic |ERROR3
Alert        |-          |FATAL |Fatal |FATAL

## Reference

- Draft discussion of Data Model:
  https://docs.google.com/document/d/1ix9_4TQO3o-qyeyNhcOmqAc1MTyr-wnXxxsdWgCMn9c/edit#

- Example mappings of existing log formats to this Data Model:
  https://docs.google.com/document/d/1ix9_4TQO3o-qyeyNhcOmqAc1MTyr-wnXxxsdWgCMn9c/edit?ts=5e990fe2#heading=h.ud60xroz7j2n

- Discussion of Severity field:
  https://docs.google.com/document/d/1WQDz1jF0yKBXe3OibXWfy3g6lor9SvjZ4xT-8uuDCiA/edit#